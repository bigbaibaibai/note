# 一、设计模式预备知识

## 1.设计模式的目的

为了使代码具有更好的

1）代码重用性（即：相同功能的代码，不用多次编写）

2）可读性（即：编程规范性，便于其他程序员阅读和理解）

3）可扩展性（即：当需要增加新的功能时，非常的方便）

4）可靠性（即：当我们增加新的功能时，不影响原有的功能）

5）使程序呈现强内聚、松耦合

## 2.设计模式的七大原则

- 单一职责原则
- 接口隔离原则
- 依赖倒转原则
- 里氏替换原则
- 开闭原则（OCP）
- 迪米特法则
- 合成复用原则

### 1）单一职责原则

基本介绍：
对类来说，即一个类应该只负责一项职责。如果类A负责两个不同的职责：职责1，职责2。当职责1需要变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2

**不遵循单一职责**

~~~java
public class SinglePrinciple1 {
    public static void main(String[] args) {
        Vehicle1 vehicle1 = new Vehicle1();
        vehicle1.run("汽车");
        vehicle1.run("飞机");
        vehicle1.run("轮船");
    }
}

/**
 * @Description: 交通工具类
 */
class Vehicle1 {
    /**
     * 这里的run方法太泛泛，并没有遵循单一职责的原则，如果是飞机或者轮船就会出问题
     * @param name
     */
    public void run(String name){
        System.out.println(name + "在路上跑");
    }
}
~~~

**采用类级别的单一职责**

~~~java
public class SinglePrinciple2 {
    public static void main(String[] args) {
        VehicleRoad vehicleRoad = new VehicleRoad();
        vehicleRoad.run("汽车");

        VehicleSky vehicleSky = new VehicleSky();
        vehicleSky.run("飞机");

        VehicleSea vehicleSea = new VehicleSea();
        vehicleSea.run("轮船");
    }
}

/**
 * @Description: 陆地交通工具 类
 */
class VehicleRoad {
    public void run(String name) {
        System.out.println(name + "在路上跑");
    }
}

/**
 * @Description: 交通空中工具 类
 */
class VehicleSky {
    public void run(String name) {
        System.out.println(name + "在天上飞");
    }
}

/**
 * @Description: 海洋交通工具 类
 */
class VehicleSea {
    public void run(String name) {
        System.out.println(name + "在海中行");
    }
}
~~~

**采用方法级别的单一职责**

~~~java
public class SinglePrinciple3 {
    public static void main(String[] args) {
        Vehicle2 vehicle2 = new Vehicle2();
        vehicle2.roadRun("汽车");
        vehicle2.skyRun("飞机");
        vehicle2.seaRun("轮船");
    }
}

class Vehicle2 {
    public void roadRun(String name) {
        System.out.println(name + "在路上跑");
    }
    public void skyRun(String name) {
        System.out.println(name + "在天上飞");
    }
    public void seaRun(String name) {
        System.out.println(name + "在海中行");
    }
}
~~~

**注意事项和细节**

1、降低类的复杂度，一个类只负责一项职责

2、提高类的可维护性和可读性

3、降低变更引起的风险

4、通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以违反单一职责，只有类中方法足够少，才可以只用方法级的单一职责

### 2）接口隔离原则

基本介绍：

1、客户端不应该依赖它不需要的接口，即==一个类对另一个类的依赖应该建立在最小的接口上==。

2、类A通过接口Interface依赖类B，类C通过接口Interface依赖类D，如果接口Interface对于类A和类C来说都不是最小接口，那么类B和类D必须去实现他们不需要的方法

3、按接口隔离原则，将接口Interface拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系，也就是采用接口隔离原则

不遵循接口隔离原则案例

```java
/**
 * @Description: 不遵循接口隔离原则
 */
public class Sergregation1 {
    public static void main(String[] args) {
        A a = new A();
        B b = new B();
        a.method1(b);
        a.method2(b);
        a.method3(b);

        C c = new C();
        D d = new D();
        c.method1(d);
        c.method4(d);
        c.method5(d);
    }
}

interface Interface{
    void method1();
    void method2();
    void method3();
    void method4();
    void method5();
}

/**
 * @Description: 类A通过接口  Interface依赖于类B（因为类B实现了类A需要的方法）
 */
class A{
    public void method1(Interface sergregation1){
        sergregation1.method1();
    }
    public void method2(Interface sergregation1){
        sergregation1.method2();
    }
    public void method3(Interface sergregation1){
        sergregation1.method3();
    }
}

/**
 * @Description:  类B实现接口，但是只用到方法1,2,3 其他的方法并不需要使用
 */
class B implements Interface{
    public void method1() {
        System.out.println("类B实现了方法1");
    }
    public void method2() {
        System.out.println("类B实现了方法2");
    }
    public void method3() {
        System.out.println("类B实现了方法3");
    }
    public void method4() {
        System.out.println("类B实现了方法4");
    }
    public void method5() {
        System.out.println("类B实现了方法5");
    }
}

/**
 * @Description: 类C通过接口  Interface依赖于类D（因为类D实现了类C需要的方法）
 */
class C{
    public void method1(Interface sergregation1){
        sergregation1.method1();
    }
    public void method4(Interface sergregation1){
        sergregation1.method4();
    }
    public void method5(Interface sergregation1){
        sergregation1.method5();
    }
}

/**
 * @Description:  类D实现接口，但是只用到方法1,4,5 其他的方法并不需要使用
 */
class D implements Interface{
    public void method1() {
        System.out.println("类D实现了方法1");
    }
    public void method2() {
        System.out.println("类D实现了方法2");
    }
    public void method3() {
        System.out.println("类D实现了方法3");
    }
    public void method4() {
        System.out.println("类D实现了方法4");
    }
    public void method5() {
        System.out.println("类D实现了方法5");
    }
}
```

遵循接口隔离原则

~~~java
public class Sergregation2 {
    public static void main(String[] args) {
        A2 a = new A2();
        B2 b = new B2();
        a.method1(b);
        a.method2(b);
        a.method3(b);

        C2 c = new C2();
        D2 d = new D2();
        c.method1(d);
        c.method4(d);
        c.method5(d);
    }
}
/**
 * @Description:  这里把一个接口细化为三个接口
 */

interface Interface1{
    void method1();
}
interface Interface2{
    void method2();
    void method3();
}
interface Interface3{
    void method4();
    void method5();
}

class A2{
    public void method1(Interface1 sergregation1){
        sergregation1.method1();
    }
    public void method2(Interface2 sergregation1){
        sergregation1.method2();
    }
    public void method3(Interface2 sergregation1){
        sergregation1.method3();
    }
}

class B2 implements Interface1,Interface2{
    public void method1() {
        System.out.println("类B实现了方法1");
    }
    public void method2() {
        System.out.println("类B实现了方法2");
    }
    public void method3() {
        System.out.println("类B实现了方法3");
    }
}


class C2{
    public void method1(Interface1 sergregation1){
        sergregation1.method1();
    }
    public void method4(Interface3 sergregation1){
        sergregation1.method4();
    }
    public void method5(Interface3 sergregation1){
        sergregation1.method5();
    }
}

class D2 implements Interface1,Interface3{
    public void method1() {
        System.out.println("类D实现了方法1");
    }
    public void method4() {
        System.out.println("类D实现了方法4");
    }
    public void method5() {
        System.out.println("类D实现了方法5");
    }
}
~~~

### 3）依赖倒转原则

基本介绍

1、高层模块不应该依赖于底层模块，二者都应该依赖其抽象

2、抽象不应该依赖细节，细节应该依赖抽象

3、依赖倒转的中心思想是面向接口编程

4、依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构要比以细节为基础的架构稳定的多。在Java中抽象指的是接口或者抽象类，细节就是具体的实现类

5、使用接口或抽象类的目的是定制熬规范，而不涉及任何具体的操作，把展现细节的任务交给它的实现类去完成